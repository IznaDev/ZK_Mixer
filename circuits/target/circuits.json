{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"13405119076411470256","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_hash","type":{"kind":"field"},"visibility":"public"},{"name":"ext_data_hash","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_proof","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"is_even","type":{"kind":"array","length":20,"type":{"kind":"boolean"}},"visibility":"private"},{"name":"recipient","type":{"kind":"field"},"visibility":"private"},{"name":"relayer","type":{"kind":"field"},"visibility":"private"},{"name":"fee","type":{"kind":"field"},"visibility":"private"},{"name":"refund","type":{"kind":"field"},"visibility":"private"},{"name":"chain_id","type":{"kind":"field"},"visibility":"private"},{"name":"contract_addr","type":{"kind":"field"},"visibility":"private"},{"name":"denomination","type":{"kind":"field"},"visibility":"private"},{"name":"deadline","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"pdjbbuIwEAbgd8k1F56xx4d9ldWqojStkCJAKay0qvrua8M/AVZylI2vPJDOV8eeMYGv7q1/vXy87A/vx8/ux8+v7nXcD8P+42U47rbn/fGQ3/363nT68uU89n1+q3u4nrNO27E/nLsfh8swbLrf2+Fy/aPP0/ZwHc/bMV81m64/vOUxg+/7oS/R9+aebeqpkgjJXmhKl+d8qudbYeQ78vf8+JTP9XzmmACwNVwTbF0g8joFoihr5hDI6xyCNTVBZuYQgtU5hFS9C18XkhMAKSf9fz4ZnlbBeFlzD8noTlDi6j3M1FIQByAaX60l01hMNFON7KP2Avtkq8RMMZC9L4Pl6laQbdzL2XVIcVoHWbUOyyqafHNJU2iuydlZNBdlJAWiN7WinMlP99PFcKoBPLcZ0xFrzcMRS4sBy7oT1sY1gJvuQR776h/AtZ7y0nzMs28/56W5LTg2twWnxuNhDljYV7O30dxXZNzDJOyKzsq7eD9prdQE21qXtr0ubXtdzhLLPnNsbCyqOWBhUS2cQ5BVu7GsPx0396dr/fheCNTXYQ5YuBez69De4NbFqShjWNPgLugDIbkY1whipoUQcquEe3dKeD5kfuVX291+fPpO1rHJjwqbjuk28G2wOb+MDqPkEs3/ln2u6PzJywFjxJhuozUYCSNjtBgdRsEIz8Kz8Cw8B8/Bc/AcPAfPwXPwHDwHz8ETeAJP4Ak8gSfwBJ7AE3gCz8Pz8Dw8D8/D8/A8PA/Pw/PwArwAL8AL8AK8AC/AC/ACvAAvwovwIrwIL8KL8CK8CC/Ci/ASvAQvwUvwErwEL8FL8BK8BI+M0YA0YA2sBk4D0cBrEDSIGqhMKpPKpDKpTCqTyqQyqUwqk8qsMqvMKrPKrDKrfG0dW4IsO1OCqEFCUNrnFpAGrIEtz7UlcBqIBlkuZxeVLnKpBFGDVFo/B6WRbgGVJ+ES8PWRuBwl4377OvT4heb9ctg9/GBz/nPSK/qTzmk87vq3y9iXg+R6LR8tfwE=","file_map":{"50":{"source":"use dep::poseidon;\n\nmod merkle_tree;\nfn main(\n    // Public inputs\n    root: pub Field,\n    nullifier_hash: pub Field,\n    ext_data_hash: pub Field,\n    // Private inputs\n    nullifier: Field,\n    secret: Field,\n    merkle_proof: [Field; 20],\n    is_even: [bool; 20],\n    // External data (kept private to the circuit, bound via ext_data_hash)\n    recipient: Field,\n    relayer: Field,\n    fee: Field,\n    refund: Field,\n    chain_id: Field,\n    contract_addr: Field,\n    denomination: Field,\n    deadline: Field,\n) {\n    // compute the commitment with Poseidon\n\n    let commitment: Field = poseidon::poseidon2::Poseidon2::hash([nullifier, secret], 2);\n\n    // check that the nullifier matches the nullifier hash\n    let computed_nullifier_hash: Field = poseidon::poseidon2::Poseidon2::hash([nullifier], 1);\n    assert(computed_nullifier_hash == nullifier_hash);\n\n    // check that the commitment is in the Incremental Merkle Tree\n    let computed_root: Field = merkle_tree::compute_merkle_root(commitment, merkle_proof, is_even);\n    assert(computed_root == root);\n\n    // bind all external data to this proof to prevent front-running or tampering\n    let computed_ext_data_hash: Field = poseidon::poseidon2::Poseidon2::hash(\n        [recipient, relayer, fee, refund, chain_id, contract_addr, denomination, deadline],\n        8,\n    );\n    assert(computed_ext_data_hash == ext_data_hash);\n\n    // recipient and relayer must be non-zero addresses (in field form)\n    assert(recipient != 0);\n    assert(relayer != 0);\n\n    // deadline must be non-zero\n    assert(deadline != 0);\n}\n","path":"/Users/oussamaboukh/Desktop/NOIR/ZK_Mixer_ameliore/circuits/src/main.nr"},"51":{"source":"use dep::poseidon;\n\npub fn compute_merkle_root(leaf: Field, merkle_proof: [Field; 20], is_even: [bool; 20]) -> Field {\n    // Store the hash for the current level\n    let mut hash: Field = leaf;\n    // Iterate over tree levels (20 levels)\n    for i in 0..20 {\n        let (left, right) = if is_even[i] {\n            (hash, merkle_proof[i])\n        } else {\n            (merkle_proof[i], hash)\n        };\n        // Hash sibling pair with Poseidon\n        hash = poseidon::poseidon2::Poseidon2::hash([left, right], 2);\n    }\n    // Return Merkle root\n    hash\n}\n","path":"/Users/oussamaboukh/Desktop/NOIR/ZK_Mixer_ameliore/circuits/src/merkle_tree.nr"},"58":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/oussamaboukh/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_invert"]}